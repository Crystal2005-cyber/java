1. History of Java

1991 – A project called Green Project was started by James Gosling and his team at Sun Microsystems.
Initially, Java was designed for interactive TV and embedded systems. The original name was Oak (named after an oak tree outside Gosling’s office).
Later renamed Java (inspired by Java coffee).
1995 – Java 1.0 was officially released.
Java became popular because of its slogan:
👉 “Write Once, Run Anywhere (WORA)”
In 2009, Sun Microsystems was acquired by Oracle, and Java is now maintained by Oracle.

2. Why Java?

Java became popular due to several features:
Platform Independent → Compile once, run anywhere (via JVM).
Object-Oriented → Supports OOP concepts (inheritance, polymorphism, encapsulation, abstraction).
Robust → Strong memory management, exception handling, garbage collection.
Secure → No explicit pointer use, has a security manager for applets.
Multithreaded → Supports concurrent execution of programs.
Distributed → Supports distributed computing with RMI and networking APIs.

3. Where Java? (Applications of Java)

Java is used in many fields:
Desktop Applications – e.g., Eclipse IDE, NetBeans.
Web Applications – JSP, Servlets, Spring, Hibernate.
Mobile Applications – Android apps are mostly Java-based.
Enterprise Applications – Banking systems, ERP, CRM.
Big Data & Cloud – Hadoop, Spark (Java-based).
Scientific Applications – MATLAB backend, simulation tools.
Games & Embedded Systems – Game engines, smart cards, sensors.

4. Difference between JDK, JRE, JVM
Component	Full Form	Purpose	Includes
JVM	Java Virtual Machine	Executes Java bytecode, provides runtime environment	Part of JRE
JRE	Java Runtime Environment	Provides libraries and JVM to run Java applications	JVM + Libraries (but no compiler)
JDK	Java Development Kit	Provides tools to develop, compile, and run Java programs	JRE + Compiler (javac) + Development tools

👉 In short:

JVM → Execution engine.

JRE → JVM + libraries (to run).

JDK → JRE + compiler + tools (to develop).



⚡1. Why is Java Platform Independent?

Java programs are written once and can run anywhere → WORA (Write Once, Run Anywhere).
This is achieved because:
Java source code (.java) is compiled into bytecode (.class) by the Java Compiler (javac).
Bytecode is not machine-specific – it’s an intermediate language.
The Java Virtual Machine (JVM) on each platform interprets (or JIT compiles) the bytecode into native machine code.
Since every OS (Windows, Linux, Mac, Android) has its own JVM implementation, the same bytecode can run anywhere without recompiling.
👉 This bytecode + JVM mechanism makes Java platform independent.

⚡2. Why is Java both interpreted and compiled?

Compiled:
Java source code is first compiled by javac into bytecode (.class).
Compilation happens only once.
Interpreted:
At runtime, the JVM interprets the bytecode line by line into native machine instructions.
Also JIT (Just-In-Time Compilation):
JVM also uses a JIT compiler that compiles frequently used parts of bytecode into native machine code for faster execution.
Hence, Java is hybrid → both compiled (into bytecode) and interpreted (by JVM).

⚡ 3. Why is Java considered slow?

Compared to languages like C/C++:
Extra Layer (JVM):
Java runs on JVM, not directly on hardware.
This extra interpretation makes it slower than native machine code.
Automatic Memory Management (Garbage Collection):
Garbage Collector (GC) adds overhead while reclaiming unused memory.
Abstraction & Security Checks:
Java performs runtime checks (array bounds, type casting, null pointer checks, etc.) which reduce raw speed.
👉 However, with JIT compilation, modern Java is much faster than it used to be and often close to C++ speed in real-world applications.

 4. Guess the output:
    class Output {
    public static void main(String[] args) {
        System.out.println("1. println ");
        System.out.println("2. println ");
        System.out.print("1. print ");
        System.out.print("2. print");
    }
}
🔎 Step-by-step execution:
System.out.println("1. println ");
→ Prints 1. println and moves to a new line.

System.out.println("2. println ");
→ Prints 2. println and moves to a new line.

System.out.print("1. print ");
→ Prints 1. print but does NOT move to a new line.

System.out.print("2. print");
→ Prints 2. print on the same line as above.

✅ Final Output:
arduino
Copy
Edit
1. println 
2. println 
1. print 2. print
